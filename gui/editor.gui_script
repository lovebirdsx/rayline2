local HexType = require 'lib.play.hex.type'
local Config = require 'lib.config.base'
local Helper = require 'lib.common.helper'
local HexPropsMgr = require 'lib.play.hex.propsmgr'

local function select_hex_b(self, hex_type)
    local old_hex_type = self.hex_type
    if old_hex_type then
        gui.set_scale(self.b_hexs[old_hex_type], self.b_hex_origin_scale)
        gui.set_position(self.b_hexs[old_hex_type], self.b_hexs_pos[old_hex_type])
    end

    self.hex_type = hex_type
    gui.set_scale(self.b_hexs[hex_type], self.b_hex_origin_scale * 1.2)
    gui.set_position(self.b_hexs[hex_type], self.b_hexs_pos[hex_type] + vmath.vector3(0, 20, 0))
end

local function reg_node(self, name, cb)
    table.insert(self.nodes, {name = name, cb = cb})
end

local function access_input(self, action_id, action)
    if action_id == hash('touch') then
        local x, y = action.x, action.y
        for _, n in ipairs(self.nodes) do
            local node = gui.get_node(n.name)
            if gui.is_enabled(node) then
                if gui.pick_node(node, x, y) then
                    if action.pressed or action.released then
                        if action.released then
                            n.cb()
                        end
                        return true
                    end
                end
            end
        end
    end

    return false
end


function init(self)
    self.nodes = {}

    reg_node(self, 'return',          function () msg.post('controller:/loader', 'stage_select', {['/manager'] = {test = true}}) end)
    reg_node(self, 'test',            function () msg.post('manager', 'test') end)
    reg_node(self, 'sync',            function () msg.post('manager', 'sync') end)
    reg_node(self, 'edit_condition',  function () msg.post('manager', 'show_condition_editor') end)
    reg_node(self, 'edit_inserter',   function () msg.post('manager', 'show_inserter_editor') end)
    reg_node(self, 'edit_server_ip',  function () msg.post('manager', 'show_server_ip_editor') end)
    reg_node(self, 'edit_hex_props',  function () msg.post('manager', 'show_hex_prop_editor') end)
    reg_node(self, 'edit_board_size', function () msg.post('manager', 'show_board_size_editor') end)
    reg_node(self, 'status',          function () gui.set_enabled(gui.get_node('status'), false) end)

    self.b_hexs = {
        [HexType.Empty] = gui.get_node('empty_hex'),
        [HexType.Normal] = gui.get_node('normal_hex'),
        [HexType.Ice] = gui.get_node('ice_hex'),
        [HexType.Bomb] = gui.get_node('bomb_hex'),
        [HexType.Icing] = gui.get_node('icing_hex'),
        [HexType.Arrow] = gui.get_node('arrow_hex'),
        [HexType.Diamond] = gui.get_node('diamond_hex'),
    }
    self.b_hexs_pos = {}
    for k, node in pairs(self.b_hexs) do
        self.b_hexs_pos[k] = gui.get_position(node)
    end

    self.b_hex_origin_scale = gui.get_scale(self.b_hexs[HexType.Empty])
    select_hex_b(self, HexType.Normal)

    self.hex_props_mgr = HexPropsMgr()

    msg.post('.', 'update')
end

function final(self)
end

local function pick_hex(self, action_id, action)
    if action_id == hash('touch') and action.released then
        for type, node in pairs(self.b_hexs) do
            if gui.pick_node(node, action.x, action.y) then
                if type ~= self.hex_type then
                    select_hex_b(self, type)
                    self.hex_props_mgr:set_selected_type(type)
                    msg.post('.', 'update')
                end

                return true
            end
        end
    end
end

function on_input(self, action_id, action)
    if access_input(self, action_id, action) then return true end
    if pick_hex(self, action_id, action) then return true end

    if action_id == hash('touch') then
        local properties = self.hex_props_mgr:get_selected_props():get_all()
        msg.post('board#script', 'change_hex', {action = action, hex_type = self.hex_type, params = properties})
    end
end

local function on_update(self)
    -- Normal Type Hex
    local normal_props = self.hex_props_mgr:get_props(HexType.Normal)
    gui.set_color(gui.get_node('normal_hex'), Config.HexColors[normal_props:get('color_id')])
    gui.set_enabled(gui.get_node('rope'), normal_props:get('tied_up'))

    -- Arrow Type Hex
    local arrow_props = self.hex_props_mgr:get_props(HexType.Arrow)
    local k = arrow_props:get('k')
    gui.set_rotation(gui.get_node('arrow_hex'), vmath.vector3(0, 0, math.deg(math.atan(k))))

    -- Diamond Type Hex
    local diamond_props = self.hex_props_mgr:get_props(HexType.Diamond)
    local lock_count = diamond_props:get('lock_count') or 0
    gui.play_flipbook(gui.get_node('diamond_hex'), 'diamond' .. lock_count)

    -- Selected Hex
    local props = self.hex_props_mgr:get_selected_props()
    gui.set_text(gui.get_node('hex_props'), props:tostring())
    if props:get_count() > 0 then
        gui.set_enabled(gui.get_node('edit_hex_props'), true)
    else
        gui.set_enabled(gui.get_node('edit_hex_props'), false)
    end
end

function on_message(self, message_id, message, sender)
    if message_id == hash('set_stg_text') then
        gui.set_text(gui.get_node('stg'), message.text)
    elseif message_id == hash('set_chp_text') then
        gui.set_text(gui.get_node('chp'), message.text)
    elseif message_id == hash('status') then
        gui.set_text(gui.get_node('status'), message.text)
        gui.set_enabled(gui.get_node('status'), true)
    elseif message_id == hash('show_conditions') then
        gui.set_text(gui.get_node('conditions'), message.text)
    elseif message_id == hash('show_inserter') then
        gui.set_text(gui.get_node('inserter'), message.text)
    elseif message_id == hash('show_server_ip') then
        gui.set_text(gui.get_node('server_ip'), message.text)
    elseif message_id == hash('update') then
        on_update(self)
    elseif message_id == hash('bind_hex_props_mgr') then
        self.hex_props_mgr = Helper.pop_table(message.id)
        select_hex_b(self, self.hex_props_mgr:get_selected_type())
        msg.post('.', 'update')
    end
end
